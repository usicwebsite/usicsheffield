"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import { getAuth, onAuthStateChanged, signOut } from 'firebase/auth';
import { doc, getDoc, collection, getDocs } from 'firebase/firestore';
import { getFirestoreDb } from '@/lib/firebase';
import { getSubmittedPosts, approvePost, rejectPost, getApprovedPosts, updatePost, getComments, getCommentCount, deleteComment, ForumPost, ForumComment } from '@/lib/firebase-utils';
import { categoryUtils } from '@/lib/static-data';

// Helper function to get Firebase ID token
const getIdToken = async (): Promise<string | null> => {
  const auth = getAuth();
  const user = auth.currentUser;
  if (!user) {
    console.log('[AdminDashboard] ‚ùå No current user for ID token');
    return null;
  }

  console.log('[AdminDashboard] üîë Getting ID token for user:', user.uid);
  try {
    const token = await user.getIdToken();
    console.log('[AdminDashboard] ‚úÖ ID token obtained, length:', token?.length);
    console.log('[AdminDashboard] üîç ID token starts with:', token?.substring(0, 50) + '...');
    return token;
  } catch (error) {
    console.error('[AdminDashboard] ‚ùå Error getting ID token:', error);
    return null;
  }
};



interface AdminStats {
  totalPosts: number;
  pendingPosts: number;
  approvedPosts: number;
  rejectedPosts: number;
  totalUsers: number;
}

interface Event {
  id: string;
  title: string;
  date: string;
  startTime: string;
  endTime?: string;
  location: string;
  price: string;
  description: string;
  imageUrl?: string;
  formFields: string[];
  signupOpen: boolean;
  createdAt: Date;
  createdBy: string;
}

interface EventFormData {
  title: string;
  date: string;
  startTime: string;
  endTime?: string;
  location: string;
  price: string;
  description: string;
  imageFile?: File;
  formFields: string[];
  signupOpen: boolean;
}


export default function AdminDashboard() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isAdmin, setIsAdmin] = useState(false);
  const [pendingPosts, setPendingPosts] = useState<ForumPost[]>([]);
  const [stats, setStats] = useState<AdminStats>({
    totalPosts: 0,
    pendingPosts: 0,
    approvedPosts: 0,
    rejectedPosts: 0,
    totalUsers: 0
  });
  const [activeTab, setActiveTab] = useState<'overview' | 'posts' | 'events'>('overview');
  const [showRejectModal, setShowRejectModal] = useState(false);
  const [selectedPostForRejection, setSelectedPostForRejection] = useState<ForumPost | null>(null);
  const [rejectionReason, setRejectionReason] = useState('');
  const [approvedPosts, setApprovedPosts] = useState<ForumPost[]>([]);
  const [editingPost, setEditingPost] = useState<ForumPost | null>(null);
  const [editTitle, setEditTitle] = useState('');
  const [editContent, setEditContent] = useState('');
  const [editCategory, setEditCategory] = useState('');
  const [postComments, setPostComments] = useState<{[postId: string]: ForumComment[]}>({});
  const [expandedPosts, setExpandedPosts] = useState<Set<string>>(new Set());
  const [commentCounts, setCommentCounts] = useState<{[postId: string]: number}>({});
  const [loadingPosts, setLoadingPosts] = useState<{[postId: string]: 'approving' | 'rejecting' | null}>({});
  
  // Events state
  const [events, setEvents] = useState<Event[]>([]);
  const [showEventForm, setShowEventForm] = useState(false);
  const [eventFormTab, setEventFormTab] = useState<'manual' | 'ai'>('manual');
  const [eventFormData, setEventFormData] = useState<EventFormData>({
    title: '',
    date: '',
    startTime: '',
    endTime: '',
    location: '',
    price: '',
    description: '',
    formFields: [],
    signupOpen: true // Default to open for signups
  });
  const [isCreatingEvent, setIsCreatingEvent] = useState(false);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [aiEventText, setAiEventText] = useState('');
  const [isProcessingAI, setIsProcessingAI] = useState(false);
  
  const [availableFormFields] = useState([
    'name',
    'email',
    'phone',
    'whatsapp',
    'student_id',
    'dietary_requirements',
    'emergency_contact',
    'transportation_needs',
    'accommodation_needs',
    'special_requests'
  ]);

  const checkAdminStatus = async (uid: string): Promise<boolean> => {
    try {
      console.log('[AdminDashboard] üîç Checking admin status for UID:', uid);
      console.log('[AdminDashboard] üîç UID type:', typeof uid);
      console.log('[AdminDashboard] üîç UID length:', uid?.length);

      const db = getFirestoreDb();
      if (!db) {
        console.error('[AdminDashboard] ‚ùå Firestore not initialized');
        return false;
      }
      console.log('[AdminDashboard] ‚úÖ Firestore initialized successfully');

      console.log('[AdminDashboard] üîç Looking for admin document at path: admins/' + uid);
      const adminDocRef = doc(db, 'admins', uid);
      console.log('[AdminDashboard] üîç Admin document reference created');

      const adminDocSnap = await getDoc(adminDocRef);
      console.log('[AdminDashboard] üîç Admin document snapshot received');
      console.log('[AdminDashboard] üîç Document exists:', adminDocSnap.exists());
      console.log('[AdminDashboard] üîç Document data:', adminDocSnap.data());

      if (adminDocSnap.exists()) {
        console.log('[AdminDashboard] ‚úÖ Admin document found - user is admin');
        return true;
      } else {
        console.log('[AdminDashboard] ‚ùå Admin document not found - user is not admin');

        // Let's also check what documents exist in the admins collection
        console.log('[AdminDashboard] üîç Checking all documents in admins collection...');
        try {
          const adminsCollection = collection(db, 'admins');
          const adminsSnapshot = await getDocs(adminsCollection);
          console.log('[AdminDashboard] üîç Total documents in admins collection:', adminsSnapshot.size);

          if (adminsSnapshot.size > 0) {
            console.log('[AdminDashboard] üîç Existing admin UIDs:');
            adminsSnapshot.forEach((doc) => {
              console.log('  - UID:', doc.id, 'Data:', doc.data());
            });
          } else {
            console.log('[AdminDashboard] ‚ùå No documents found in admins collection');
          }
        } catch (collectionError) {
          console.error('[AdminDashboard] ‚ùå Error listing admins collection:', collectionError);
        }

        return false;
      }
    } catch (error) {
      console.error('[AdminDashboard] ‚ùå Error checking admin status:', error);
      console.error('[AdminDashboard] ‚ùå Error details:', {
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined
      });
      return false;
    }
  };

  useEffect(() => {
    console.log('[AdminDashboard] Starting authentication check...');

    const auth = getAuth();
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      try {
        console.log('[AdminDashboard] Auth state changed:', user ? 'User found' : 'No user');

        if (!user) {
          console.log('[AdminDashboard] No authenticated user, redirecting to login');
          router.push('/admin-login');
          return;
        }

        console.log('[AdminDashboard] User authenticated, checking admin status...');
        console.log('[AdminDashboard] üîç User UID from Firebase:', user.uid);
        console.log('[AdminDashboard] üîç User email from Firebase:', user.email);
        console.log('[AdminDashboard] üîç User display name:', user.displayName);

        // Check admin status in Firestore
        const isAdminUser = await checkAdminStatus(user.uid);

        if (!isAdminUser) {
          console.log('[AdminDashboard] User is not an admin, signing out and redirecting');
          await signOut(auth);
          router.push('/admin-login');
          return;
        }

        console.log('[AdminDashboard] Admin verification successful, loading dashboard');
        setIsAdmin(true);
        setIsAuthenticated(true);
        setIsLoading(false);
        await loadDashboardData();
      } catch (err) {
        console.error('[AdminDashboard] Authentication error:', err);
        router.push('/admin-login');
      }
    });

    return () => unsubscribe();
  }, [router]);

  // Load approved posts when Posts tab is selected
  useEffect(() => {
    if (activeTab === 'posts' && isAuthenticated && isAdmin && approvedPosts.length === 0) {
      loadApprovedPosts();
    }
  }, [activeTab, isAuthenticated, isAdmin, approvedPosts.length]);

  // Load events when Events tab is selected
  useEffect(() => {
    if (activeTab === 'events' && isAuthenticated && isAdmin && events.length === 0) {
      loadEvents();
    }
  }, [activeTab, isAuthenticated, isAdmin, events.length]);

  const loadDashboardData = async () => {
    try {
      console.log('[AdminDashboard] Loading dashboard data...');
      setIsLoading(true);
      
      // Load submitted posts directly from Firestore
      console.log('[AdminDashboard] Loading submitted posts...');
      const submittedPosts = await getSubmittedPosts(50);
      console.log('[AdminDashboard] Loaded', submittedPosts.length, 'submitted posts');

      setPendingPosts(submittedPosts);

      // Load approved posts for stats
      console.log('[AdminDashboard] Loading approved posts for stats...');
      const approvedPostsData = await getApprovedPosts();
      console.log('[AdminDashboard] Loaded', approvedPostsData.length, 'approved posts');

      // Calculate basic stats
      const totalPosts = submittedPosts.length + approvedPostsData.length;
      const totalUsers = 0; // Placeholder for now

      setStats({
        totalPosts,
        pendingPosts: submittedPosts.length,
        approvedPosts: approvedPostsData.length,
        totalUsers,
        rejectedPosts: 0 // We'll load this if needed
      });

    } catch (error) {
      console.error('[AdminDashboard] Failed to load dashboard data:', error);
    } finally {
      console.log('[AdminDashboard] Setting loading to false');
      setIsLoading(false);
    }
  };

  const loadApprovedPosts = async () => {
    try {
      console.log('[AdminDashboard] Loading approved posts...');
      setIsLoading(true);

      const posts = await getApprovedPosts(undefined, 100); // Load up to 100 approved posts
      console.log('[AdminDashboard] Loaded', posts.length, 'approved posts');

      setApprovedPosts(posts);

      // Load comment counts for all posts
      console.log('[AdminDashboard] Loading comment counts for posts...');
      const counts: {[postId: string]: number} = {};
      await Promise.all(posts.map(async (post) => {
        if (post.id) {
          const count = await getCommentCount(post.id);
          counts[post.id] = count;
        }
      }));

      setCommentCounts(counts);
      console.log('[AdminDashboard] Loaded comment counts:', counts);
    } catch (error) {
      console.error('[AdminDashboard] Failed to load approved posts:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const loadEvents = async () => {
    try {
      console.log('[AdminDashboard] Loading events...');
      setIsLoading(true);

      // Get ID token for authentication
      const token = await getIdToken();
      if (!token) {
        throw new Error('Failed to get authentication token');
      }

      // Fetch events from the admin API
      const response = await fetch('/api/admin/events', {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to fetch events');
      }

      const data = await response.json();
      console.log('[AdminDashboard] Loaded', data.events?.length || 0, 'events');
      
      setEvents(data.events || []);
    } catch (error) {
      console.error('[AdminDashboard] Failed to load events:', error);
    } finally {
      setIsLoading(false);
    }
  };


  const handleDeletePost = async (postId: string) => {
    if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
      return;
    }

    try {
      console.log('[AdminDashboard] Deleting post:', postId);
      
      // Get Firebase ID token for authentication
      const idToken = await getIdToken();
      if (!idToken) {
        throw new Error('Unable to get authentication token');
      }
      
      // Call the API endpoint to delete the post
      const response = await fetch(`/api/admin/posts/${postId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${idToken}`,
        },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to delete post');
      }

      const result = await response.json();
      console.log('[AdminDashboard] Post deleted successfully:', result);

      // Remove from approved posts list
      setApprovedPosts(prev => prev.filter(post => post.id !== postId));

      // Update stats
      setStats(prev => ({
        ...prev,
        approvedPosts: prev.approvedPosts - 1,
        totalPosts: prev.totalPosts - 1
      }));

      console.log('[AdminDashboard] Post deleted successfully');
    } catch (error) {
      console.error('Error deleting post:', error);
      alert('Failed to delete post. Please try again.');
    }
  };

  const startEditingPost = (post: ForumPost) => {
    setEditingPost(post);
    setEditTitle(post.title);
    setEditContent(post.content);
    setEditCategory(post.category);
  };

  const cancelEditing = () => {
    setEditingPost(null);
    setEditTitle('');
    setEditContent('');
    setEditCategory('');
  };

  const savePostEdits = async () => {
    if (!editingPost) return;

    try {
      console.log('[AdminDashboard] Updating post:', editingPost.id);

      const updates = {
        title: editTitle.trim(),
        content: editContent.trim(),
        category: editCategory.trim(),
        updatedAt: new Date()
      };

      await updatePost(editingPost.id!, updates);

      // Update the post in the approved posts list
      setApprovedPosts(prev =>
        prev.map(post =>
          post.id === editingPost.id
            ? { ...post, ...updates }
            : post
        )
      );

      cancelEditing();
      console.log('[AdminDashboard] Post updated successfully');
    } catch (error) {
      console.error('Error updating post:', error);
      alert('Failed to update post. Please try again.');
    }
  };

  const toggleComments = async (postId: string) => {
    const newExpanded = new Set(expandedPosts);
    if (newExpanded.has(postId)) {
      newExpanded.delete(postId);
      } else {
      newExpanded.add(postId);
      // Load comments if not already loaded
      if (!postComments[postId]) {
        try {
          const comments = await getComments(postId);
          setPostComments(prev => ({
            ...prev,
            [postId]: comments
          }));
        } catch (error) {
          console.error('Error loading comments:', error);
        }
      }
    }
    setExpandedPosts(newExpanded);
  };

  const handleDeleteComment = async (commentId: string, postId: string) => {
    if (!confirm('Are you sure you want to delete this comment? This action cannot be undone.')) {
      return;
    }

    try {
      console.log('[AdminDashboard] Deleting comment:', commentId);
      await deleteComment(commentId);

      // Remove comment from local state
      setPostComments(prev => ({
        ...prev,
        [postId]: prev[postId].filter(comment => comment.id !== commentId)
      }));

      // Update comment count
      setCommentCounts(prev => ({
        ...prev,
        [postId]: Math.max(0, (prev[postId] || 0) - 1)
      }));

      console.log('[AdminDashboard] Comment deleted successfully');
    } catch (error) {
      console.error('Error deleting comment:', error);
      alert('Failed to delete comment. Please try again.');
    }
  };





  const handleApprovePost = async (postId: string) => {
    try {
      console.log('[AdminDashboard] Approving post:', postId);
      
      // Set loading state
      setLoadingPosts(prev => ({ ...prev, [postId]: 'approving' }));
      
      const auth = getAuth();
      const user = auth.currentUser;

      if (!user || !postId) {
        console.error('[AdminDashboard] No authenticated user or invalid post ID');
        setLoadingPosts(prev => ({ ...prev, [postId]: null }));
        return;
      }

      // Use the new approvePost function from firebase-utils
      await approvePost(postId, user.uid);

        // Remove from pending posts
        setPendingPosts(prev => prev.filter(post => post.id !== postId));
      // Update stats
      setStats(prev => ({
        ...prev,
        pendingPosts: prev.pendingPosts - 1,
        approvedPosts: prev.approvedPosts + 1
      }));

      console.log('[AdminDashboard] Post approved successfully');
    } catch (error) {
      console.error('Error approving post:', error);
      // You could show an error message to the user here
    } finally {
      // Clear loading state
      setLoadingPosts(prev => ({ ...prev, [postId]: null }));
    }
  };

  const handleRejectPost = async (postId: string, rejectionReason: string) => {
    try {
      console.log('[AdminDashboard] Rejecting post:', postId, 'with reason:', rejectionReason);
      
      // Set loading state
      setLoadingPosts(prev => ({ ...prev, [postId]: 'rejecting' }));
      
      const auth = getAuth();
      const user = auth.currentUser;

      if (!user || !postId) {
        console.error('[AdminDashboard] No authenticated user or invalid post ID');
        setLoadingPosts(prev => ({ ...prev, [postId]: null }));
        return;
      }

      // Use the new rejectPost function from firebase-utils
      await rejectPost(postId, user.uid, rejectionReason);

        // Remove from pending posts
        setPendingPosts(prev => prev.filter(post => post.id !== postId));
      // Update stats
      setStats(prev => ({
        ...prev,
        pendingPosts: prev.pendingPosts - 1,
        rejectedPosts: (prev.rejectedPosts || 0) + 1
      }));

        // Close modal and reset state
        setShowRejectModal(false);
        setSelectedPostForRejection(null);
        setRejectionReason('');

      console.log('[AdminDashboard] Post rejected successfully');
    } catch (error) {
      console.error('Error rejecting post:', error);
      // You could show an error message to the user here
    } finally {
      // Clear loading state
      setLoadingPosts(prev => ({ ...prev, [postId]: null }));
    }
  };

  const handleAIAssistedEventCreation = async () => {
    if (!aiEventText.trim()) {
      alert('Please enter event details');
      return;
    }

    try {
      setIsProcessingAI(true);

      const token = await getIdToken();
      if (!token) {
        throw new Error('Failed to get authentication token');
      }

      // Call the AI parsing API
      const response = await fetch('/api/admin/events/parse-event-ai', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ eventText: aiEventText }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to parse event details');
      }

      const data = await response.json();

      // Fill the form with parsed data
      setEventFormData({
        title: data.title || '',
        date: data.date || '',
        startTime: data.startTime || '',
        endTime: data.endTime || '',
        location: data.location || '',
        price: data.price || '',
        description: data.description || aiEventText,
        formFields: [], // Default empty, user can select
        signupOpen: true,
        imageFile: undefined
      });

      // Switch to manual tab so user can review/edit
      setEventFormTab('manual');
      setAiEventText('');

    } catch (error) {
      console.error('Error processing AI event creation:', error);
      alert(error instanceof Error ? error.message : 'Failed to process event details');
    } finally {
      setIsProcessingAI(false);
    }
  };

  const handleCreateEvent = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (eventFormData.formFields.length === 0) {
      alert('Please select at least one form field');
      return;
    }

    if (!eventFormData.startTime) {
      alert('Please select a start time');
      return;
    }

    try {
      setIsCreatingEvent(true);
      
      const auth = getAuth();
      const user = auth.currentUser;
      
      if (!user) {
        throw new Error('No authenticated user');
      }

      // Create FormData for the request
      const formData = new FormData();
      formData.append('title', eventFormData.title);
      formData.append('date', eventFormData.date);
      formData.append('startTime', eventFormData.startTime);
      if (eventFormData.endTime) {
        formData.append('endTime', eventFormData.endTime);
      }
      formData.append('location', eventFormData.location);
      formData.append('price', eventFormData.price);
      formData.append('description', eventFormData.description);
      formData.append('formFields', JSON.stringify(eventFormData.formFields));
      formData.append('signupOpen', eventFormData.signupOpen.toString());
      formData.append('createdBy', user.uid);
      
      if (eventFormData.imageFile) {
        formData.append('image', eventFormData.imageFile);
      }

      // Get ID token for authentication
      const token = await getIdToken();
      if (!token) {
        throw new Error('Failed to get authentication token');
      }

      // Call the API to create the event
      const response = await fetch('/api/admin/events', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create event');
      }

      const result = await response.json();
      
      // Add the new event to the events list
      const newEvent: Event = {
        id: result.eventId,
        title: eventFormData.title,
        date: eventFormData.date,
        startTime: eventFormData.startTime,
        endTime: eventFormData.endTime,
        location: eventFormData.location,
        price: eventFormData.price,
        description: eventFormData.description,
        imageUrl: result.imageUrl,
        formFields: eventFormData.formFields,
        signupOpen: eventFormData.signupOpen,
        createdAt: new Date(),
        createdBy: user.uid
      };
      
      setEvents(prev => [newEvent, ...prev]);
      
      // Reset form and close modal
      setEventFormData({
        title: '',
        date: '',
        startTime: '',
        endTime: '',
        location: '',
        price: '',
        description: '',
        formFields: [],
        signupOpen: true
      });
      setImagePreview(null);
      setShowEventForm(false);
      
      console.log('Event created successfully:', result.eventId);
    } catch (error) {
      console.error('Error creating event:', error);
      alert(error instanceof Error ? error.message : 'Failed to create event');
    } finally {
      setIsCreatingEvent(false);
    }
  };

  const openRejectModal = (post: ForumPost) => {
    setSelectedPostForRejection(post);
    setRejectionReason('');
    setShowRejectModal(true);
  };

  const closeRejectModal = () => {
    setShowRejectModal(false);
    setSelectedPostForRejection(null);
    setRejectionReason('');
  };

  const submitRejection = () => {
    if (selectedPostForRejection && selectedPostForRejection.id && rejectionReason.trim()) {
      handleRejectPost(selectedPostForRejection.id, rejectionReason.trim());
    }
  };



  const handleLogout = async () => {
    try {
      // Sign out from Firebase Auth
      await signOut(getAuth());

      // Redirect to login page
      router.push('/admin-login');
    } catch (error) {
      console.error('Error signing out:', error);
      // Even if sign out fails, redirect to login
      router.push('/admin-login');
    }
  };

  const formatDate = (timestamp: Date | { toDate(): Date }) => {
    if (!timestamp) return "Unknown date";

    const date = 'toDate' in timestamp ? timestamp.toDate() : new Date(timestamp);
    return date.toLocaleDateString("en-GB", {
      day: "numeric",
      month: "short",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  const formatTimeRange = (startTime: string, endTime?: string) => {
    if (!startTime) return "Time not set";

    // Format the start time
    const formatTime = (timeStr: string) => {
      const [hours, minutes] = timeStr.split(':');
      const hour = parseInt(hours);
      const ampm = hour >= 12 ? 'PM' : 'AM';
      const displayHour = hour % 12 || 12;
      return `${displayHour}:${minutes} ${ampm}`;
    };

    const formattedStart = formatTime(startTime);

    if (endTime) {
      const formattedEnd = formatTime(endTime);
      return `${formattedStart} - ${formattedEnd}`;
    }

    return formattedStart;
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-[#18384D]">
        {/* Header */}
        <header className="bg-[#234b64] shadow-lg">
          <div className="container mx-auto px-4 py-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <Image
                  src="/1. USIC Full Logo.svg"
                  alt="USIC Logo"
                  width={40}
                  height={40}
                  className="w-auto h-10"
                  style={{ filter: 'invert(1)' }}
                />
                <h1 className="text-white text-2xl font-bold">USIC Admin Dashboard</h1>
              </div>
            </div>
          </div>
        </header>

        {/* Loading Content */}
        <div className="flex items-center justify-center min-h-[calc(100vh-80px)]">
          <div className="text-center max-w-md mx-auto">
            <div className="mb-8">
              <div className="w-20 h-20 mx-auto mb-6 relative">
                <div className="absolute inset-0 rounded-full border-4 border-gray-300/30"></div>
                <div className="absolute inset-0 rounded-full border-4 border-transparent border-t-blue-400 animate-spin"></div>
                <div className="absolute inset-2 rounded-full bg-blue-400/20 animate-pulse"></div>
              </div>
              <h2 className="text-white text-2xl font-semibold mb-2">Loading Dashboard</h2>
              <p className="text-gray-300 text-sm">Please wait while we prepare your admin panel...</p>
            </div>
            
            {/* Loading Steps */}
            <div className="space-y-3 text-left">
              <div className="flex items-center space-x-3">
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                <span className="text-gray-300 text-sm">Verifying authentication...</span>
              </div>
              <div className="flex items-center space-x-3">
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse" style={{ animationDelay: '0.2s' }}></div>
                <span className="text-gray-300 text-sm">Loading dashboard data...</span>
              </div>
              <div className="flex items-center space-x-3">
                <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse" style={{ animationDelay: '0.4s' }}></div>
                <span className="text-gray-300 text-sm">Preparing admin interface...</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (!isAuthenticated || !isAdmin) {
    router.push('/admin-login');
    return null;
  }

  return (
    <div className="min-h-screen bg-[#18384D]">
      {/* Header */}
      <header className="bg-[#234b64] shadow-lg">
        <div className="container mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <Image
                src="/1. USIC Full Logo.svg"
                alt="USIC Logo"
                width={40}
                height={40}
                className="w-auto h-10"
                style={{ filter: 'invert(1)' }}
              />
              <h1 className="text-white text-2xl font-bold">USIC Admin Dashboard</h1>
            </div>
            <div className="flex items-center space-x-4">
              <button
                onClick={handleLogout}
                className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md transition duration-300"
              >
                Logout
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Navigation */}
      <nav className="bg-[#1a3a4d] border-b border-white/10">
        <div className="container mx-auto px-4">
          <div className="flex space-x-8 py-4">
            <button
              onClick={() => setActiveTab('overview')}
              className={`py-2 px-4 border-b-2 transition-colors ${
                activeTab === 'overview'
                  ? 'border-blue-500 text-blue-300'
                  : 'border-transparent text-gray-300 hover:text-white'
              }`}
            >
              Overview
            </button>
            <button
              onClick={() => setActiveTab('posts')}
              className={`py-2 px-4 border-b-2 transition-colors ${
                activeTab === 'posts'
                  ? 'border-blue-500 text-blue-300'
                  : 'border-transparent text-gray-300 hover:text-white'
              }`}
            >
              Manage Posts
            </button>
            <button
              onClick={() => setActiveTab('events')}
              className={`py-2 px-4 border-b-2 transition-colors ${
                activeTab === 'events'
                  ? 'border-blue-500 text-blue-300'
                  : 'border-transparent text-gray-300 hover:text-white'
              }`}
            >
              Manage Events
            </button>
          </div>
        </div>
      </nav>

      {/* Main Content */}
      <main className="container mx-auto px-4 py-8">
        {/* Tab content will be rendered here */}
      </main>

        {/* Event Creation Modal */}
        {showEventForm && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto">
              <div className="p-6">
                <div className="flex items-center justify-between mb-6">
                  <h3 className="text-xl font-semibold text-gray-900">Create New Event</h3>
                  <button
                    onClick={() => {
                      setShowEventForm(false);
                    setEventFormTab('manual');
                    setAiEventText('');
                      if (imagePreview) {
                        URL.revokeObjectURL(imagePreview);
                        setImagePreview(null);
                      }
                    }}
                    className="text-gray-400 hover:text-gray-600"
                  >
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>

                {/* Tabs */}
                <div className="flex space-x-1 mb-6 bg-gray-100 p-1 rounded-lg">
                          <button
                    onClick={() => setEventFormTab('manual')}
                    className={`flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all ${
                      eventFormTab === 'manual'
                        ? 'bg-white text-gray-900 shadow-sm'
                        : 'text-gray-500 hover:text-gray-700'
                    }`}
                  >
                    Manual Entry
                          </button>
                    <button
                    onClick={() => setEventFormTab('ai')}
                    className={`flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all ${
                      eventFormTab === 'ai'
                        ? 'bg-white text-gray-900 shadow-sm'
                        : 'text-gray-500 hover:text-gray-700'
                    }`}
                  >
                    AI Assisted
                    </button>
                  </div>

                <div className="space-y-6">
                  <p>Test modal content</p>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Rejection Reason Modal */}
        {showRejectModal && selectedPostForRejection && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
              <h3 className="text-lg font-semibold mb-4 text-gray-900">Reject Post</h3>

              <div className="mb-4">
                <h4 className="font-medium text-gray-800 mb-2">Post Title:</h4>
                <p className="text-gray-600 text-sm">{selectedPostForRejection.title}</p>
              </div>

              <div className="mb-4">
                <label htmlFor="rejectionReason" className="block text-sm font-medium text-gray-700 mb-2">
                  Rejection Reason *
                </label>
                <textarea
                  id="rejectionReason"
                  value={rejectionReason}
                  onChange={(e) => setRejectionReason(e.target.value)}
                  rows={4}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent"
                  placeholder="Please provide a reason for rejecting this post..."
                  required
                />
              </div>

              <div className="flex justify-end space-x-3">
                <button
                  onClick={closeRejectModal}
                  className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50 transition duration-300"
                >
                  Cancel
                </button>
                <button
                  onClick={submitRejection}
                  disabled={!rejectionReason.trim() || (selectedPostForRejection?.id ? loadingPosts[selectedPostForRejection.id] === 'rejecting' : false)}
                  className="px-4 py-2 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white rounded-md transition duration-300 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                  {selectedPostForRejection?.id && loadingPosts[selectedPostForRejection.id] === 'rejecting' ? (
                    <>
                      <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                      Rejecting...
                    </>
                  ) : (
                    'Reject Post'
                  )}
                </button>
              </div>
            </div>
          </div>
        )}

      </main>
    </div>
  );
} 
